package fr.hadriel.network;

import fr.hadriel.event.IEvent;
import fr.hadriel.event.IEventListener;
import fr.hadriel.events.DataEvent;
import fr.hadriel.events.UpdateEvent;
import fr.hadriel.serialization.Serial;
import fr.hadriel.threading.Loop;
import fr.hadriel.time.Timer;
import fr.hadriel.util.Property;

import java.io.IOException;
import java.net.*;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * Created by glathuiliere on 08/08/2016.
 */
public class UDPSocket extends Loop {

    public static final int DEFAULT_BUFFER_SIZE = 1400;

    private InetAddress address;
    private int port;
    private DatagramSocket socket;

    //Receive system
    private IEventListener dispatcher;
    private Lock lock = new ReentrantLock();
    private Property<Integer> bufferSizeProperty;
    private DatagramPacket receivePacket;
    private Timer timer;

    public UDPSocket(InetAddress address, int port, int bufferSize) {
        this.address = address;
        this.port = port;

        this.bufferSizeProperty = new Property<>(bufferSize, DEFAULT_BUFFER_SIZE);
        this.bufferSizeProperty.addCallback((size) -> receivePacket = new DatagramPacket(new byte[bufferSize], bufferSize));
        this.receivePacket = new DatagramPacket(new byte[bufferSize], bufferSize); // initialization set
        this.timer = new Timer();
    }

    public UDPSocket(InetAddress address, int port) {
        this(address, port, DEFAULT_BUFFER_SIZE);
    }

    public UDPSocket(int port, int bufferSize) {
        this(null, port, bufferSize);
    }

    public UDPSocket(int port) {
        this(null, port, DEFAULT_BUFFER_SIZE);
    }

    public UDPSocket() {
        this(null, 0, DEFAULT_BUFFER_SIZE);
    }

    public int getBufferSize() {
        return bufferSizeProperty.get();
    }

    public void setBufferSize(int bufferSize) {
        bufferSizeProperty.set(bufferSize);
    }

    protected void onStart() {
        try {
            socket = new DatagramSocket(port, address);
            address = socket.getLocalAddress();
            port = socket.getLocalPort();
            socket.setSoTimeout(500); // thread will block for 1 second max
            timer.reset();
        } catch (SocketException e) {
            e.printStackTrace();
        }
    }

    protected void onLoop() {
        //In case onStart failed
        if(socket == null) {
            interrupt();
            return;
        }

        //Clean receivePacket address
        receivePacket.setAddress(null);

        //Listen over the network
        try {
            socket.receive(receivePacket);
        } catch (IOException ignore) {}

        //Always (even without message received)
        fireEvent(new UpdateEvent(timer.elapsed()));
        timer.reset();

        //Filter if no message is received
        if(receivePacket.getAddress() == null)
            return;

        //Extract Data
        InetAddress address = receivePacket.getAddress();
        int port = receivePacket.getPort();
        byte[] buffer = receivePacket.getData();
        int offset = receivePacket.getOffset();
        int length = receivePacket.getLength();
        int channel = Serial.readInt(buffer, offset);
        offset += 4;
        byte[] data = new byte[length - offset];
        System.arraycopy(buffer, 4, data, 0, data.length);

        //Process Data
        fireEvent(new DataEvent(address, port, data, channel));
    }

    protected void onStop() {
        socket.close();
        socket = null;
    }

    public InetAddress getAddress() {
        return address;
    }

    public int getPort() {
        return port;
    }

    public void send(InetAddress address, int port, byte[] data, int channel) {
        send(address, port, data, 0, data.length, channel);
    }

    public void send(InetAddress address, int port, byte[] data, int offset, int length, int channel) {
        requireRunning();
        byte[] buffer = new byte[length + 4 - offset];
        Serial.write(buffer, 0, channel); //channel overhead
        System.arraycopy(data, offset, buffer, 4, data.length); // copy data to the buffer
        try {
            //Send the generated byte array
            socket.send(new DatagramPacket(buffer, 0, buffer.length, address, port));
        } catch (IOException ignore) {
            ignore.printStackTrace();
        }
    }

    private void fireEvent(IEvent event) {
        lock.lock();
        if(dispatcher != null)
            dispatcher.onEvent(event);
        lock.unlock();
    }

    public void setDispatcher(IEventListener dispatcher) {
        lock.lock();
            this.dispatcher = dispatcher;
        lock.unlock();
    }

    public IEventListener getDispatcher() {
        IEventListener listener = null;
        lock.lock();
        listener = dispatcher;
        lock.unlock();
        return listener;
    }
}